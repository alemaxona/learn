// Типы данных (всего - 6)
// number - 4, 4.32 Нет разделения на дробное и целое!
// Строки как в Python
// Boolean как в Python, только с маленькой буквы!

// И еще 3:
// null
// object ({objKey: "balue"})
// undefined - Значение неопределено!
// null - Значение отсутствует/пустое значение.

// ООП в JS нет, есть полиморфизм.
// В JS практически нет Exeptions
// ; - Можно ставить, можно - нет, но в некоторых местах она нужна! Лучше всегда ставить!

'use strict'; // Необходимо всегда писать в самом начале скрипта! Строгий режим/Современный стандарт, для обратной совместимости!
// Если указать эту строку внутри функции, то современный режим будет работать только внутри функции!

// В JS принято писать в стиле camelCase
// Ковычки могуть быть и те и другие.
var s = 'My var';
var myVar = "My var"

s = undefined
console.log(s)
// undefined
s = null
console.log(s)
// null

alert( 1 / 0 ); // Infinity, бесконечность.
alert( "нечисло" * 2 ); // // Nan - не число!, ошибка

s = 'My var'

console.log(s == myVar)  // Вывод на экран
// true
console.log(s === myVar)
// true
console.log(typeof(s))  //console.log(typeof s)
// string

console.error(s)  // Вывод ошибок
// My var  // Error

// Объекты
var o = {}
console.log(o)
// {}
console.log(typeof(o))
// object

// Результат typeof null == "object" – это официально признанная ошибка в языке, 
// которая сохраняется для совместимости. На самом деле null – это не объект, а отдельный тип данных.

// Объект в JS - это как dict в Python!
// Наследования нет, классов нет!
o['key'] = 12
console.log(o.key)  // Но уже ['some key'] через точку не получится!
// 12
console.log(o["key"])
// 12

// Списки - так же, как и в Python, но это не тип, а - объект! О_о
// В данном случае ключ 0 = 1, ключ 1 = 2 и ключ 2 = 3!
var list = [1, 2, 3]
// (3) [1, 2, 3]
console.log(typeof(list))
// object
list.push('str')  // Добавление в список
console.log(list)
// 4) [1, 2, 3, "str"]

/*
Скрипты вставляются на страницу как текст в теге <script>, либо как внешний файл через <script src="путь"></script>
Специальные атрибуты async и defer используются для того, чтобы пока грузится внешний скрипт – браузер показал остальную (следующую за ним) часть страницы. Без них этого не происходит.
Разница между async и defer: атрибут defer сохраняет относительную последовательность скриптов, а async – нет. Кроме того, defer всегда ждёт, пока весь HTML-документ будет готов, а async – нет.
*/

// Договоренность о объявлении констант:
// Технически, константа является обычной переменной, то есть её можно изменить. Но мы договариваемся этого не делать.
var COLOR_RED = '#F00'

// Таблица приоритетов
// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Operator_Precedence
var x = 2 * 2 + 1;
alert( x ); 
// 5

var apples = "2";
var oranges = "3";
alert(apples + oranges);  
//'23'
alert( +apples + +oranges ); 
// 5, число, оба операнда предварительно преобразованы в числа

var a = 1;
var b = 2;
var c = 3 - (a = b + 1);
alert( a ); 
// 3
alert( c ); 
// 0

alert( 5 % 2 ); 
// 1

var i = 2;
i++;      // более короткая запись для i = i + 1.
alert(i); 
// 3

 var i = 2;
i--;      // более короткая запись для i = i - 1.
alert(i); 
// 1

// Если результат оператора не используется, а нужно только увеличить/уменьшить 
// переменную – без разницы, какую форму использовать:
// ---------------------------
var i = 0;
i++;
++i;
alert( i ); 
// 2

// !!! 
var i = 1;
var a = ++i;  // Префиксная форма. Если хочется тут же использовать результат.
alert(a); 
// 2

var i = 1;
var a = i++; // Постфиксная форма. Если нужно значение до увеличения.
alert(a); 
// 1

alert( 2 * i++ ); // 2,  выполнился раньше но значение вернул старое
alert( i ); // 2
alert( 2 * i++ ); // 4
alert( i ); // 3


var i = 1;
alert( 2 * ++i ); // 4
alert( i ); // 2
alert( 2 * ++i ); // 6
alert( i ); // 3
// ---------------------------

var n = 2;
n += 5; // теперь n=7 (работает как n = n + 5). Так можно сделать для операторов +,-,*,/,%

// Строки сравниваются побуквенно.
// Значения разных типов приводятся к числу при сравнении, за исключением строгого равенства === (!==).
// Значения null и undefined равны == друг другу и не равны ничему другому.
// В обычном операторе == есть «проблема» – он не может отличить 0 от false:
 alert( 0 == false ); // true
// Та же ситуация с пустой строкой:
 alert( '' == false ); // true
// Это естественное следствие того, что операнды разных типов преобразовались к числу. 
// Пустая строка, как и false, при преобразовании к числу дают 0.
// Что же делать, если всё же нужно отличить 0 от false?
// Для проверки равенства без преобразования типов используются операторы строгого равенства === (тройное равно) и !==.
// Если тип разный, то они всегда возвращают false:
 alert( 0 === false ); // false, т.к. типы различны


//  prompt как и alert - модальные окна. То есть, пока их не закрыть, работа со страницей не продолжится.

var years = prompt('Сколько вам лет?', 100);  // Esc - отмена окна
// 'Сколько вам лет?' - Заголовок
// 100 - значение, которое показывается в строке ввода по умолчанию.
alert('Вам ' + years + ' лет!')

var test = prompt("Тест");
var test = prompt("Тест", '');   // Рекомендуется всегда ставить второй аргумент( для совместимости в IE)


var isAdmin = confirm("Вы - администратор?");  // OK or Cancel
alert( isAdmin ); // true or false

